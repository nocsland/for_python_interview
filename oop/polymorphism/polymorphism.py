# Полиморфизм
#
# Термин полиморфизм буквально означает наличие нескольких форм. В контексте объектно - ориентированного
# программирования, полиморфизм означает способность объекта вести себя по - разному. Полиморфизм в программировании
# реализуется через перегрузку метода, либо через его переопределение.
#
# Перегрузка метода
#
# Перегрузка метода относится к свойству метода вести себя по - разному, в зависимости от количества или типа
# параметров. Взглянем на очень простой пример перегрузки метода.
#
# Выполним следующий скрипт:

# создаем класс Car

class Car:
    def start(self, a, b=None):
        if b is not None:
            print(a + b)
        else:
            print(a)


# В скрипте выше, если метод start() вызывается передачей одного аргумента, параметр будет выведен на экран. Однако,
# если мы передадим 2 аргумента методу start(), он внесет оба аргумента и выведет результат суммы.

# Попробуем с одним аргументом для начала:

car_a = Car()
car_a.start(10)

# В выдаче мы можем видеть 10. Теперь попробуем передать два аргумента:

car_a.start(10, 20)


# В выдаче вы увидите 30.

# Переопределение метода

# Переопределение метода относится к наличию метода с одинаковым названием в дочернем и родительском классах.
# Определение метода отличается в родительском и дочернем классах, но название остается тем же.
#
# Давайте посмотрим на простой пример переопределения метода в Python.


# создание класса Vehicle
class Vehicle:
    def print_details(self):
        print("Это родительский метод из класса Vehicle")


# создание класса, который наследует Vehicle
class Car(Vehicle):
    def print_details(self):
        print("Это дочерний метод из класса Car")


# создание класса Cycle, который наследует Vehicle
class Cycle(Vehicle):
    def print_details(self):
        print("Это дочерний метод из класса Cycle")


# В скрипте выше, классы Cycle и Car наследуют класс Vehicle. Класс Vehicle содержит метод print_details(), который
# переопределен дочерним классом. Теперь, если вы вызовите метод print_details(), выдача будет зависеть от объекта,
# через который вызывается метод.

# Выполните следующий скрипт, чтобы понять суть на деле:

car_a = Vehicle()
car_a.print_details()

car_b = Car()
car_b.print_details()

car_c = Cycle()
car_c.print_details()

# Выдача будет выглядеть вот так:

# Это родительский метод из класса Vehicle
# Это дочерний метод из класса Car
# Это дочерний метод из класса Cycle


# Как вы видите, выдача отличается, к тому же метод print_details() вызывается через производные классы одного и того же
# базового класса. Однако, так как дочерние классы переопределены методом родительского класса, методы ведут себя по -
# разному.
